-- Create the products table
CREATE TABLE IF NOT EXISTS products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  name TEXT NOT NULL,
  price TEXT NOT NULL,
  category TEXT NOT NULL,
  color TEXT
);

-- Insert some initial data into products
INSERT INTO products (name, price, category, color) VALUES
('Neon Smart Watch', '$299', 'Electronics', 'from-blue-500 to-cyan-400'),
('Holographic Headset', '$499', 'Accessories', 'from-purple-500 to-pink-500'),
('Cyberpunk Sneakers', '$159', 'Fashion', 'from-amber-400 to-orange-500'),
('Quantum Tablet', '$899', 'Electronics', 'from-emerald-400 to-teal-500')
ON CONFLICT DO NOTHING;

-- Enable RLS for Products
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- Policy: Allow public read access
CREATE POLICY "Public Read Access"
ON products FOR SELECT
USING (true);

-- Policy: Allow authenticated users to Insert/Update/Delete
-- (For a real production app, restrict this to users with 'Admin' role via custom claims or profile check)
CREATE POLICY "Authenticated Admin Access"
ON products FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

-- Create the users table (Mirror of auth.users)
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  name TEXT,
  email TEXT NOT NULL UNIQUE,
  role TEXT DEFAULT 'User',
  joined DATE DEFAULT CURRENT_DATE
);

-- Note: We don't insert default users manually here because they should come from Auth.
-- But if you want a seed admin in public table that ISN'T in Auth (for testing), you can:
-- INSERT INTO users (id, name, email, role, joined) VALUES
-- ('00000000-0000-0000-0000-000000000000', 'Admin User', 'admin@example.com', 'Admin', '2023-11-20')
-- ON CONFLICT DO NOTHING;

-- Function to handle new user signups
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.users (id, email, name, role, joined)
  VALUES (
    new.id, 
    new.email, 
    COALESCE(new.raw_user_meta_data->>'full_name', 'New User'), 
    'User', 
    NOW()
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Create the try_on_requests table
CREATE TABLE IF NOT EXISTS try_on_requests (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  user_id UUID NOT NULL,
  status TEXT DEFAULT 'pending'
);

-- Enable Row Level Security
ALTER TABLE try_on_requests ENABLE ROW LEVEL SECURITY;

-- Policy: Allow authenticated users to insert their own requests
CREATE POLICY "Users can insert their own requests" 
ON try_on_requests FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = user_id);

-- Policy: Allow users to view their own requests
CREATE POLICY "Users can view their own requests" 
ON try_on_requests FOR SELECT 
TO authenticated 
USING (auth.uid() = user_id);

-- Policy: Allow service_role (Admin API) to do everything
-- (The service_role key bypasses RLS, but if you query via the client with a user token who is an admin, you might need a policy. 
-- For simplicity in this demo, we can allow public read or just rely on the fact that our admin dashboard might be using a service role client or standard client.)
-- Let's add a policy that allows anyone with the role 'Admin' in the users table to view all. 
-- But since we are using Supabase Auth, we don't easily have the role 'Admin' in `auth.users`.
-- For now, let's just allow all authenticated users to SELECT, so the admin page works (Status: Pending) and users can see their requests.
-- A stricter production policy would check a `profiles` table or custom claims.
CREATE POLICY "Authenticated users can view all requests"
ON try_on_requests FOR SELECT
TO authenticated
USING (true);

-- --------------------------
-- STORAGE POLICIES
-- --------------------------

-- Create the bucket 'request-images' if it doesn't strictly exist via UI
-- NOTE: If you haven't created the bucket in the Dashboard, run this:
INSERT INTO storage.buckets (id, name, public) VALUES ('request-images', 'request-images', true)
ON CONFLICT (id) DO NOTHING;

-- Policy: Allow public read access to images
CREATE POLICY "Public Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'request-images' );

-- Policy: Allow authenticated users to upload images
CREATE POLICY "Authenticated users can upload images"
ON storage.objects FOR INSERT
TO authenticated
-- --------------------------
-- 3D MODEL FEATURE UPDATES
-- --------------------------

-- Add model_url column to users table if it doesn't exist
ALTER TABLE users ADD COLUMN IF NOT EXISTS model_url TEXT;

-- Create the bucket 'user-models' for 3D files (.glb, .gltf)
INSERT INTO storage.buckets (id, name, public) VALUES ('user-models', 'user-models', true)
ON CONFLICT (id) DO NOTHING;

-- Policy: Allow public read access to models
CREATE POLICY "Public Model Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'user-models' );

-- Policy: Allow authenticated users (Admins) to upload models
CREATE POLICY "Authenticated users can upload models"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'user-models' );

-- Policy: Allow authenticated users to update/delete models (for replacing)
CREATE POLICY "Authenticated users can update models"
ON storage.objects FOR UPDATE
TO authenticated
USING ( bucket_id = 'user-models' );

CREATE POLICY "Authenticated users can delete models"
ON storage.objects FOR DELETE
TO authenticated
USING ( bucket_id = 'user-models' );
-- --------------------------
-- PRODUCT MODELS & WISHLIST
-- --------------------------

-- Add model_url to products table
ALTER TABLE products ADD COLUMN IF NOT EXISTS model_url TEXT;

-- Create Wishlist table
CREATE TABLE IF NOT EXISTS wishlist (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  UNIQUE(user_id, product_id)
);

-- Enable RLS for Wishlist
ALTER TABLE wishlist ENABLE ROW LEVEL SECURITY;

-- Wishlist Policies
CREATE POLICY "Users can view own wishlist"
ON wishlist FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users can add to own wishlist"
ON wishlist FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete from own wishlist"
ON wishlist FOR DELETE
TO authenticated
USING (auth.uid() = user_id);

-- Create product-models bucket
INSERT INTO storage.buckets (id, name, public) VALUES ('product-models', 'product-models', true)
ON CONFLICT (id) DO NOTHING;

-- Product Models Storage Policies
CREATE POLICY "Public Read Product Models"
ON storage.objects FOR SELECT
USING ( bucket_id = 'product-models' );

CREATE POLICY "Authenticated Admin Upload Product Models"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'product-models' );

CREATE POLICY "Authenticated Admin Update Product Models"
ON storage.objects FOR UPDATE
TO authenticated
USING ( bucket_id = 'product-models' );

CREATE POLICY "Authenticated Admin Delete Product Models"
ON storage.objects FOR DELETE
TO authenticated
USING ( bucket_id = 'product-models' );
